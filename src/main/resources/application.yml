spring:
  application:
    name: ssf
  # When using the default reactive mode (preferred), exclude DataSource auto-configuration
  # and prefer R2DBC to avoid accidental blocking DataSource creation.
  # To use JDBC instead, activate the 'jdbc' profile which will enable DataSource auto-configuration.
  autoconfigure:
    exclude: org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
  datasource:
    url: jdbc:oracle:thin:@//${ORACLE_HOST:localhost}:${ORACLE_PORT:1521}/${ORACLE_DB:FREEPDB1}
    driver-class-name: oracle.jdbc.OracleDriver
    username: ${ORACLE_USER:APP_USER}
    password: ${ORACLE_PASSWORD:ssfpassword}
    hikari:
      connection-timeout: 30000
      maximum-pool-size: 20
      minimum-idle: 5
      auto-commit: true
      validation-timeout: 5000
      leak-detection-threshold: 60000
      max-lifetime: 1800000
      idle-timeout: 600000
      connection-test-query: SELECT 1 FROM DUAL
      data-source-properties:
        oracle.jdbc.fanEnabled: true
        oracle.jdbc.fastConnectionFailover: true
        oracle.net.CONNECT_TIMEOUT: 10000
        oracle.net.READ_TIMEOUT: 60000
        oracle.jdbc.implicitStatementCacheSize: 25
        oracle.jdbc.maxCachedBufferSize: 65536
  jpa:
    database-platform: org.hibernate.dialect.OracleDialect
    hibernate:
      ddl-auto: validate
    defer-datasource-initialization: false
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.OracleDialect
        jdbc:
          batch_size: 100
          fetch_size: 50
  cache:
    type: caffeine
    caffeine:
      spec: maximumSize=500,expireAfterWrite=10m,recordStats
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD}
      timeout: 2000ms
      database: 0
    relational:
      # Disable automatic identifier quoting to prevent Spring Data R2DBC from wrapping
      # table/column names in quotes. Oracle doesn't need quoted identifiers for lowercase
      # names since it treats them case-insensitively.
      naming-strategy: ANSI
  r2dbc:
    url: r2dbc:oracle://${ORACLE_HOST:localhost}:${ORACLE_PORT:1521}/${ORACLE_DB:FREEPDB1}
    username: ${ORACLE_USER:APP_USER}
    password: ${ORACLE_PASSWORD:ssfpassword}

# Cache Service Configuration
# Configures individual cache behavior (query result cache and session cache)
# Properties are read by CacheConfiguration class using Spring's @ConfigurationProperties
cache:
  config:
    # Query Result Cache: caches GraphQL/database query results
    query-result-cache:
      max-size: 1000                  # Maximum number of cache entries
      ttl-minutes: 15                 # Time-to-live in minutes before entries expire
    
    # Session Cache: caches user session data
    session-cache:
      max-size: 5000                  # Maximum number of cache entries
      ttl-minutes: 60                 # Time-to-live in minutes (1 hour)

server:
  port: 8443
  ssl:
    key-store: classpath:keystore.p12
    key-store-password: ${KEYSTORE_PASSWORD:changeit}
    key-store-type: PKCS12
    key-alias: ssf

# Batch operations configuration
batch:
  size: 200                          # Default batch size (100-500 based on memory profiling)
  max-retries: 3                     # Max retries with exponential backoff
  initial-retry-delay-ms: 100        # Initial retry delay in milliseconds
  memory-threshold-percent: 80       # Trigger batch size reduction at 80% heap usage

oracle:
  array:
    min-chunk-size: 500              # Lower bound chunk size under extreme memory pressure
    default-chunk-size: 2000         # Default associative array chunk size
    max-chunk-size: 10000            # Max chunk size when heap headroom allows
    eden-pause-threshold-percent: 80 # Pause producer when Eden occupancy exceeds this percent
    pause-duration-ms: 250           # Back-pressure duration when throttling array producers

query:
  streaming:
    fetch-size: 500                  # Default fetch size for cursor-based streaming
    max-fetch-size: 10000            # Upper bound fetch size when memory headroom allows
    idle-timeout-seconds: 30         # Cursor idle timeout to prevent orphaned streams

app:
  jwt:
    secret: ${JWT_SECRET}
  security:
    enable-default-user-role: false  # Least-privilege: no implicit roles unless explicitly enabled
  minio:
    url: http://localhost:9000
    access-key: ${MINIO_ACCESS_KEY}
    secret-key: ${MINIO_SECRET_KEY}
  r2dbc:
    host: ${ORACLE_HOST:localhost}
    port: ${ORACLE_PORT:1521}
    database: ${ORACLE_DB:FREEPDB1}
    username: ${ORACLE_USER:APP_USER}
    password: ${ORACLE_PASSWORD:ssfpassword}
    pool:
      min-idle: 10
      max-size: 80              # Keep aligned with Oracle capacity and <4x Hikari max
      queue-depth: 150          # Prevent deep backlog from exhausting DB sessions
      idle-timeout: PT30M
    # If you prefer Spring's boot R2DBC auto-configuration, uncomment and set the following properties
    # spring.r2dbc.url: r2dbc:oracle://${ORACLE_HOST:localhost}:${ORACLE_PORT:1521}/${ORACLE_DB:FREEPDB1}
    # spring.r2dbc.username: ${ORACLE_USER:APP_USER}
    # spring.r2dbc.password: ${ORACLE_PASSWORD:ssfpassword}

# Use this flag to enable the blocking JDBC DataSource (default: false)
  datasource:
    enabled: false

ssf:
  cache:
    default-max-age: 3600            # Default Cache-Control max-age in seconds (1 hour)


management:
  endpoints:
    web:
      exposure:
        include: ${MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE:health,metrics}
  endpoint:
    health:
      show-details: when-authorized

schema:
  bootstrap:
    enabled: true
    continue-on-error: true